处理复制线程崩溃恢复的最佳实践：
配置项：
1，如果使用GTID复制，则启用SOURCE_AUTO_POSITION=1；
2，如果使用基于文件位置复制，推荐sync_relay_log=1（注意，这个表示对于io_thread读取的每一个event，而不是transction，都执行一次sync磁盘的操作。这几乎是不可接受的）。这是因为，sql_thread已经应用了对应的event，但是io_thread可能并没有将对应的event 内容sync到磁盘上，那么此时发生崩溃的话，在重启后的复制恢复过程中，恢复线程会基于已经sync到磁盘的relay位置确定恢复开始位置，那么对于没有sync到磁盘的event就会重复恢复。造成恢复失败。对于这个原因，个人觉得可以通过设置relay_log_recovery = ON，在恢复开始时删除存在的relay_log文件，此时，io_thread会根据relay repository中记录的应用信息重新从maser拉取日志。自然就避免了以relay_log实际位置开始复制导致的问题。
	the event of an unexpected halt of a replica there might be committed transactions that have not been synchronized to disk. Such transactions can cause the recovery process to fail if the recovering replica, based on the information it has in the relay log as last synchronized to disk, tries to retrieve and apply the transactions again instead of skipping them. 

	另一方面，对于MTS，如果崩溃发生时，存在gap的话，在恢复过程中，如果恢复线程不能利用relay_log文件的内容，填平这些gap，也会发生错误。
	如果relay log文件缺失内容，relay_log_recovery = ON 是否能解决这个原因导致的问题，需要看代码才能知道。 根据文档的描述， relay log recover过程在创建了新relay log并且将sql_thread、io_thread指向新位置后，采用与START REPLICA | SLAVE UNTIL SQL_AFTER_MTS_GAPS 一样的方式处理gap（UNTIL SQL_AFTER_MTS_GAPS不启动io_thread）， 在gap填平后才会从master拉取新日志到新创建的relay log文件中。 这个时候还没有开始从master拉取日志。 那么，如果旧的relay log本身有缺失， 那肯定是恢复不了的。所以还是要等待看代码才能理清其中的逻辑。

	这些问题只会发生在基于文件位置的恢复方式中。对于GTID的方式，由于对应的GTID已经apply过，所以会直接跳过，不会造成重复应用。对于gap情况下同时发生的relay log内容缺失，再次连接的过程中会自动获取缺失的日志。
3，innodb_flush_log_at_trx_commit=1。这个没什么说的，任何非紧急情况，都应该如此设置。
4，relay_log_info_repository = TABLE
5，relay_log_recovery = ON。这个变量的生效方式为，在server启动过程中，创建新的relay_log，并且将sql_thread的relay position指向新创建的relay log文件，接着，再将io_thread指向sql_thread的位置。老的relay log文件会自动删除掉。 对于GTID中SOURCE_AUTO_POSITION=1情况应该没什么作用， 这种情况会自动获取不存在的事务，并跳过已经apply的事务。





监控RBR复制：
1，打开监控项探针：
UPDATE performance_schema.setup_instruments SET ENABLED = 'YES'
 WHERE NAME LIKE 'stage/sql/Applying batch of row changes%';

2，查看监控信息：
SELECT WORK_COMPLETED, WORK_ESTIMATED FROM performance_schema.events_stages_current
 WHERE EVENT_NAME LIKE 'stage/sql/Applying batch of row changes%'；

3，如果binlog_rows_query_log_events选项启用的话，原始的sql语句会记录在binlog中，显示在performance_schema.threads的processlist_info列上。
SELECT db, processlist_state, processlist_info FROM performance_schema.threads
 WHERE processlist_state LIKE 'stage/sql/Applying batch of row changes%' AND thread_id = N;







对master和slave使用不同的引擎：
1，master上建表时，不指定engine选项，通过default_storage_engine选项指定。
2，当表复制到salve上时，因为default_storage_engine不会随binlog复制到slave上，可以在salve上设置成自己想要的engine。
另外，如果master上建表时指定了engine选项，那么可以在salve上通过disabled_storage_engines或者skip-xxx选项禁用特定的存储引擎，同时搭配default_storage_engine选项，以及sql_mode不要指定NO_ENGINE_SUBSTITUTION 选项达到目的。
3，个别表可以通过重建表的方式修改存储引擎。








复制异步连接故障切换：
8.0.20版本引入的新功能，用于在从库上给单个通道创建一个 master池，从库可以根据master池中不同master的weight权重选择最高的master进行连接。
要求：
1，使用GTID，并且master_auto_position=1；#因为当发生fail over时需要在不同的master之间切换。需要利用GTID的自动跳过事务以及自动获取没有的事务的特性。
2，SOURCE_CONNECTION_AUTO_FAILOVER=1；
3，从库可以使用一套用户密码连接到所有的master实例，用户密码必须在change master to时指定；  
	#通过:
		asynchronous_connection_failover_add_source(channel, host, port, network_namespace, weight)
		asynchronous_connection_failover_delete_source(channel, host, port, network_namespace)
		asynchronous_connection_failover_add_managed(channel, managed_type, managed_name, host, port, network_namespace, primary_weight, secondary_weight)
		asynchronous_connection_failover_delete_managed(channel, managed_name)
	4个函数，都没有配置用户密码的地方，用户密码是从change master中设置的参数进行获取。因此，change master to时必须指定用户密码。而不能留在start slave时启动。
4，复制连接用户需要有权限查询performance_schema的权限，因为需要根据其中的replication_asynchronous_connection_failover 、 replication_asynchronous_connection_failover_managed  视图，获取当前配置的master池的实例与对应实例的配置信息。

特性：
1，如果当前连接的master断开，或者出现了新的weight高于当前master的实列，则从库自动切换到新的master上进行复制。
2，可以添加一个组复制组中的一个server，之后mysql自动添加组中的其它server。并且可以为组中的primary和secondary角色分别指定不同weight。

注意：
1，需要修改change master to 中的MASTER_CONNECT_RETRY(连接重试的间隔，单位s) MASTER_RETRY_COUNT(连接重试的次数)参数。因为这两个参数的默认值可以让从库一致重试连接60天。达不到故障切换的目的了。
2，mysql通过thread/sql/replica_monitor线程，不断追踪组复制组中的成员关系的改变（加入，退出，角色切换等）。
3，两种视图：
mysql|performance_schema.replication_asynchronous_connection_failover：配置的所有的master。包括通过单个添加，或者添加的组复制中组的成员。
mysql|performance_schema.replication_asynchronous_connection_failover_managed：配置的组复制组信息。




