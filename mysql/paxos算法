paxos算法
目标：一些推举的值最终被选中，并且，一旦一个值被选中，那这个值最终可以被进程学习。

达成共识的安全要求：
1，仅仅被推举的值可以被选择
2，仅仅可以选中一个值
3，在一个值被选中被选中之前，进程绝无可能直到此值已经被选中(提前押宝)

三种角色：
proposers： 提议者
acceptors： 接受者
learners ： 学习者

算法的假设前提：
一个进程可以同时扮演多种角色，进程间通过定制化的异步消息传递，系统不存在拜占庭将军问题(节点可以处于故障状态，但是所有节点都不会发出错误、恶意的信息)。
1，进程可以以任意速度运行，可能由于失败停止，或者重启。如果一个节点在系统选中一个值后故障，那么这个节点必须能记住(保存)一些信息，以便重启后恢复。
2，消息可以花费任意长的时间传递，可以丢失，可以重复，但是一定是正确的。



算法法则(需求)：
需求1：在理想情况下，仅仅一个proposer提出了一个值V(v)，这个值应该被选中  -> 法则P1: acceptor必须接受它收到的第一个值。
P1法则在复杂的情况下，导致了一个问题：即，当同时有多个proposer提出了多个不同的值V1~Vn ，每个acceptor都接受了各自收到的第一个Vk(v)， 那么就存在无法达成共识(只接受一个value)的情况即，超过半数的acceptor都接受同一个Vk(v)。w
为了解决这个问题，就需要引入一个新的需求：
需求2：accetor必须被允许接受多个提案值V(v)。(思考一下，多个V<v>,一个acceptor接受了其中的一部分V， 拒绝了一部分V， 那就有可能最终达成大部分acceptor都接受的一个V )
为了追踪acceptor接受的多个提案， 需要记录proposer的编号。因此所有的proposer都被赋予了唯一的编号，并且提案也变成了V(p,v),其中p标识proposer的编号。







non-Byzantine model：来源于拜占庭将军故障。原意为一些军队围住了一座敌人的城池，这些军队都听命于自身的将军，其中有忠诚的将军，也有叛徒将军。 如果要打下这座城，所有忠诚的将军必须在同一时刻发动攻击。 所有将军两两之间都单线直接联系，忠诚的将军需要就攻击时间点达成一致，叛徒将军将会尝试愚弄忠诚将军，以使攻击并非在同一时刻发起。
在分布式系统中，将军代表了分布式中的节点，忠诚将军代表正常运行的节点，叛徒将军代表出现故障的节点(会发出错误的信息，甚至是恶意的信息)。所有节点需要就当前系统的整体状态达成一致。